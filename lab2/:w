#include <stdio.h>
#include <string.h>
#include "node.h"
#include "syntax.tab.h"

void init() {
	int i;
	for (i = 0; i < HASHSIZE; i ++)
		varHashtable[i] = stack[i] = NULL;
		funcHashtable[i] = NULL;
}

void insertVar(FieldList var) {
	unsigned int index = hash_pjw(var->name);	
	if (varHashtable[index] == NULL)
		varHashtable[index] = var;
	else {
		var->tail = varHashtable[index]->tail;
		varHashtable[index]->tail = var;
		var->tail->head = var;
	}
}

void travel(struct node *root) {
	if (root == NULL) return ;

	ExtDefList(root->child);
}

void ExtDefList(struct node *root) {
	if (root == NULL) return ;

	ExtDef(root->child);
	ExtDefList(root->child);
}

void ExtDef(struct node *root) {
	if (root == NULL) return ;

	struct node *child = root->child;
	Type type = Specifier(child);
	
	if (strcmp(child->next->type, "ExtDecList") == 0) 
		ExtDecList(child->next, type);
	else if (strcmp(child->next->type, "FunDec") == 0) {
		FunctionMessage *funType = FunDec(child->next, type);
		if (strcmp(child->next->next->type, "SEMI") == 0) 
			funType->visitedTag = 0;
		else { 
			funType->visitedTag = 1;
			FieldList index = funType->argList;
			FieldList last = NULL;  
			while (index != NULL) {							//将函数的参数插入符号表
				stack[top] = (FieldList)malloc(sizeof(FieldList_));
				FieldList tmp = stack[top ++];
				tmp->name = malloc(strlen(index->name) + 1);
				strcpy(tmp->name, index->name);
				tmp->lineno = index->lineno;
				tmp->type = index->type;					//这里不再malloc
				tmp->tail = tmp->head = tmp->down = NULL;
				if (last != NULL) last->down = tmp;
				last = tmp;
				insertVar(tmp);
				index = index->tail;
			}
			//函数定义里的Compst，把参数传入，和第一层的Compst中的变量比较，不能有相同, 并且把返回类型传入
		 	Compst(child->next->next, stack[top-1], type);	
			//Compst结束后，会把函数体内的变量都free，包括函数的参数
		}
	}
}

void ExtDecList(struct node *root, Type type) {
	if (root == NULL) return ;

	struct node *child = root->child;
	FieldList tmp = VarDec(child, type);
	insertVar(tmp);

	if (child->next != NULL)
		ExtDecList(child->next->next, type);
}

Type Specifier(struct node *root) {
	if (root == NULL) return NULL;
	
	struct node *child = root->child;
	Type ret;
	if (strcmp(child->type, "TYPE") == 0) {
		ret = (Type)malloc(sizeof(Type_));
		if (strcmp(child->value, "INT") == 0)
			ret->kind = 0;			
		else if (strcmp(child->value, "FLOAT") == 0)
			ret->kind = 1;
	} else 
		ret = StructSpecifier(child);
	
	return ret;
}

Type StructSpecifier(struct node *root) {
	if (root == NULL) return NULL;

	struct node *child = root->child->next;
	if (strcmp(child->type, "LC") == 0 || child->next != NULL) {				//结构体的定义,放入结构体定义表中
		int flag = strcmp(child->type, "LC");
		FieldList tmp = (FieldList)malloc(sizeof(FieldList_));
		if (flag) {
			tmp->name = malloc(strlen(child->value) + 1);
			strcpy(tmp->name, child->value);
		}
		tmp->type = (Type)malloc(sizeof(Type_)); 
		tmp->type->kind = 2;
		if (flag) 
			tmp->type->u.structure = DefList(child->next->next, 1);
		else 
			tmp->type->u.structure = DefList(child->next, 1);
		int ret = insertStruct(tmp);
		if (ret || varHashtable[hash_pjw(child->value)] != NULL) 	//已经定义了这个结构体，或者结构体名称和已有变量冲突
			printf("Error type 16 at Line %d: Duplicated name \"%s\"\n", child->line, child->type);
		return tmp->type;
	} else {				//用结构体定义一个变量
		unsigned int index = hash_pjw(child->value); 
		if (structHashtable[index] == NULL) 	//这个结构体并没有定义过
			printf("Error type 17 at Line %d: Undefined structure \"%s\"", child->line, child->value);
		else {				
			Type ret = (Type)malloc(sizeof(Type_));
			ret->kind = 2;
			ret->u.structure = structHashtable[index]->type->u.structure;
			return ret;
		}
	}
}

FieldList DefList(struct node *root, int isStruct) {
	if (root == NULL) return NULL;

	struct node *child = root->child;

	FieldList ret = Def(child, isStruct);
	ret->down = DefList(child->next, isStruct);

	return ret;
}

FieldList Def(struct node *root, int isStruct) {
	if (root == NULL) return NULL;

	struct node *child = root->child;
	Type type = Specifier(child);
	
	FieldList ret = DecList(child->next, type, isStruct);

	return ret;
}

FieldList DecList(struct node *root, Type type, int isStruct)  {
	if (root == NULL) return NULL;

	struct node *child = root->child;
	FieldList ret = Dec(child, type, isStruct);

	child = child->next; 
	if (child != NULL) {
		FieldList tmp = ret;
		while (tmp->down != NULL) tmp = tmp->down;
		tmp->down = DecList(child->next, type, isStruct);
	}

	return ret;
}

FieldList Dec(struct node *root, Type type, int isStruct) {
	if (root == NULL) return NULL;

	struct node *child = root->child;
	FieldList ret = VarDec(child, type);	

	if (child->next != NULL) {
		FieldList tmp = Exp(child->next->next);
		if (compareType(tmp->type, type) != 0) 
			printf("Error type 5 at Line %d: Type mismatched for assignment.\n", child->line);
	}
	return ret;
}

void Compst(struct node *root, FieldList var, Type returnType) {
	if (root == NULL) return ;

	struct node *child = root->child->next;		//DefList
	FieldList varIn = DefList(child, 0);	
	if (var != NULL && varIn != NULL) {			//函数定义部分的Compst
		FieldList store = varIn;
		while (varIn != NULL) {
			FieldList tmp = var;
			int flag = 0;
			while (tmp != NULL) {
				if (compare(varIn, tmp) == 0) {
					printf("Error Type 3 at Line %d: Redefined variable %s\n", tmp->lineno, tmp->name);
					flag = 1;
				}
				tmp = tmp->down;
			}
			if (!flag) insertVar(varIn);
			varIn = varIn->down;
		}
		//把和函数参数同一层的变量链表接到参数表的后方
		varIn = store;
		while (var->down!= NULL) var = var->down;
		var->down = varIn;
	} else {					//StmtList部分的Compst
		FieldList st = stack[top ++];
		st = varIn;
		while (varIn != NULL) {
			insertVar(varIn);
			varIn = varIn->down;
		}
	}

	StmtList(child->next, returnType);

	del(stack[top-1]); top --;
}

void StmtList(struct node *root, Type returnType) {
	if (root == NULL) return ;
	
	struct node *child = root->child;
	Stmt(child, returnType);
	StmtList(child->next, returnType);
}

void Stmt(struct node *root, Type returnType) {
	if (root == NULL) return ;

	struct node *child = root->child;
	if (strcmp(child->type, "Exp") == 0) 
		Exp(child);
	else if (strcmp(child->type, "Compst") == 0) 
		Compst(child, NULL, returnType);
	else if (strcmp(child->type, "RETURN") == 0) {
		FieldList tmp = Exp(child->next);
		if (compareType(tmp->type, returnType)) 
			printf("Error type 8 at Line %d: Type mismatched for return.\n", child->next->line);
	} else if (strcmp(child->type, "IF") == 0) {
		Exp(child->next->next);
		child = child->next->next->next->next;
		Stmt(child, returnType);
		if (child->next != NULL) 
			Stmt(child->next->next, returnType);
	} else {
		Exp(child->next->next);
		child = child->next->next;
		Stmt(child->next->next, returnType);
	}
}

FunctionMessage *FunDec(struct node *root, Type type) {
	if (root == NULL) return NULL;

	FunctionMessage *ret = (FunctionMessage *)malloc(sizeof(FunctionMessage));
	struct node *child = root->child;

	ret->name = malloc(strlen(child->value)+1);
	strcpy(ret->name, child->value);
	ret->lineno = child->line;
	ret->returnType = type;
	ret->next = NULL;

	if (strcmp(child->next->next->type, "RP") == 0) 
		ret->argList = NULL;
	else 
		ret->argList = VarList(child->next->next);
	
	return ret;
}

FieldList VarList(struct node *root) {
	if (root == NULL) return NULL;

	FieldList ret;
	struct node *child = root->child;

	ret = ParamDec(child);
	child = child->next;

	if (child != NULL) {
		FieldList tmp = VarList(child->next);
		if (ret == NULL) ret = tmp;
		else {
			FieldList iter = ret;
			int flag = 0;
			while (iter->tail != NULL) {	
				if (compare(iter, tmp) == 0) flag = 1;
				iter = iter->tail;
			}
			iter->tail = tmp;
			if (flag)			//函数定义时，参数重复定义
				printf("Error Type 3 at Line %d: Redefined variable \"%s\".\n", child->line, tmp->name);
		}
	}

	return ret;
}

FieldList ParamDec(struct node *root) {
	if (root == NULL) return NULL;

	struct node *child = root->child;
	Type type = Specifier(child);
	
	return VarDec(child->next, type);
}

FieldList VarDec(struct node *root, Type type) {
	if (root == NULL) return NULL;

	FieldList ret;
	struct node *child = root->child;
	if (child->next == NULL) {				//ID
		ret = (FieldList)malloc(sizeof(FieldList_));
		ret->name = malloc(strlen(child->value) + 1);
		strcpy(ret->name, child->value);
		ret->type = type;
		ret->tail = NULL;
	} else {
		ret = VarDec(child, type);
		Type temp = (Type)malloc(sizeof(Type_));
		temp->kind = 1;
		temp->u.array.elem = ret->type;
		temp->u.array.size = atoi(child->next->next->value);
		ret->type = temp;
	}

	return ret;
}

FieldList Exp(struct node *root) {
	if (root == NULL) return NULL;

	struct node *child = root->child;
	if (strcmp(child->type, "Exp") == 0) {
		FieldList tmp1 = Exp(child);
		if (strcmp(child->next->next->type, "Exp") == 0) {
			FieldList tmp2 = Exp(child->next->next);
			if (strcmp(child->next->type, "ASSIGNOP") == 0) {
				struct node *tmp = child->child;
				int flag = 0;
				if (strcmp(tmp->type, "ID") == 0 && tmp->next == NULL) flag = 1;
				if (strcmp(tmp->type, "Exp") == 0 && 
					strcmp(tmp->next->type, "LB") == 0 || strcmp(tmp->next->type, "DOT") == 0) flag = 1;
				if (!flag) 
					printf("Error type 6 at Line %d: The left-hand side of an assignment must be a variable.\n", child->line);
			} else if (strcmp(child->next->type, "LB") == 0) {
				if (tmp1->type->kind != 2) 
					printf("Error type 10 at Line %d: \"%s\" is not an array.\n", tmp1->lineno, tmp1->name);
				if (tmp2->type->kind != 0)
					printf("Error type 12 at Line %d: \"%lf\" is not an integer.\n", tmp2->lineno, tmp2->type->u.basic.floatValue);
			} else if (strcmp(child->next->type, "DOT") == 0) {
				if (tmp1->type->kind != 3) 
					printf("Error type 13 at Line %d: Illegal use of \".\".\n", child->line);
			} else {
				int flag = 0;
				if (compareType(tmp1->type, tmp2->type)) flag = 1;
				if ((tmp1->type->kind != 0 && tmp1->type->kind != 1) || 
					(tmp2->type->kind != 0 && tmp2->type->kind != 1)) flag = 1;
				if (flag) 
					printf("Error type 7 at Line %d: Type mismatched for operands.\n", child->line);
			}
		}
	}
	if (strcmp(child->type, "LP") == 0) {
		return Exp(child->next);
	}
	if (strcmp(child->type, "MINUS") == 0 || strcmp(child->type, "NOT") == 0) {
		FieldList tmp = Exp(child->next);
		if (tmp->type->kind != 0 && tmp->type->kind != 1) 
			printf("Error type 7 at Line %d: Type mismatched for operands.\n", child->line);
		return tmp;
	}
	if (strcmp(child->type, "ID") == 0 && child->next != NULL) {
		FunctionMessage *func = funcHashtable[hash_pjw(child->value)];
		if (func == NULL) {
			printf("Error type 2 at Line %d: Undefined function \"%s\".\n", child->line, child->value);
			return NULL;
		}
		if (func->visitedTag == 0) {
			printf("Error type 18 at Line %d: Undefined function \"%s\".\n", child->line, child->value);
			return NULL;
		}
		struct node *arg;
		if (strcmp(child->next->next->type, "Args") == 0) 
			arg = child->next->next;
		else 
			arg = NULL;
		FieldList argList = Args(arg);
		if (compare(argList, func->argList) != 0) {
			printf("Error type 9 at Line %d: Function arguments mismatched.\n", child->line);
			return NULL;
		}
	}
	if (strcmp(child->type, "ID") == 0) {
		FieldList ret = varHashtable[hash_pjw(child->value)];
		if (ret == NULL) 
			printf("Error type 1 at Line %d: Undefined variable \"%s\".\n", child->line, child->value);
		return ret;
	}
	if (strcmp(child->type, "INT") == 0 || strcmp(child->type, "FLOAT") == 0) {
		int flag = 0;
		if (strcmp(child->type, "FLOAT") == 0) flag = 1;
		FieldList ret = (FieldList)malloc(sizeof(FieldList_));
		ret->name = NULL;
		ret->lineno = child->line;
		ret->type = (Type)malloc(sizeof(Type_));
		ret->type->kind = flag;
		if (flag == 0)
			ret->type->u.basic.intValue = atoi(child->value);
		else 
			ret->type->u.basic.floatValue = atof(child->value);
		ret->tail = ret->head = ret->down = NULL;

		return ret;
	}
}

FieldList Args(struct node *root) {
	if (root == NULL) return NULL;

	struct node *child = root->child;
	FieldList ret = Exp(child);

	if (child->next != NULL) 
		ret->down = Args(child->next->next);
	
	return ret;
}

int compare(FieldList v1, FieldList v2) {	
	//同为结构体，且相同
	if (compareType(v1->type, v2->type) == 0 && v1->type->kind == 3)
		return 0;				
	//否则就判断变量名字
	if (strcmp(v1->name, v2->name) == 0) 
		return 0;
}

int compareType(Type t1, Type t2) {
	while ( 1 ) {
		if (t1->kind != t2->kind) return 1;				//类型不同，直接返回
		if (t1->kind == 0 || t1->kind == 1) return 0;	//基本类型，直接返回
		if (t1->kind == 2) {
			t1 = t1->u.array.elem;
			t2 = t2->u.array.elem;
			continue;
		}
		return compare(t1->u.structure, t2->u.structure);
	}
}

int insertStruct(FieldList struc) {
	int index = hash_pjw(struc->name);	

	if (structHashtable[index] == NULL) {
		structHashtable[index] = struc;
		return 0;
	}
	FieldList tmp = structHashtable[index];
	while (tmp != NULL) {
		if (compare(tmp, struc) == 0) return 1;
		tmp = tmp->tail;
	}
	struc->tail = structHashtable[index]->tail;
	structHashtable[index]->tail->head = struc;
	structHashtable[index] = struc;
	return 0;
}

void del(FieldList obj) {
	if (obj == NULL) return ;
	while (obj != NULL) {
		FieldList tmp = obj;
		obj = obj->down;
		free(tmp->name);
		dell(tmp->type);	
		free(tmp);
	}
}

void dell(Type type) {
	if (type == NULL) return ;
	if (type->kind == 0 || type->kind == 1) {
		free(type); return ;
	}
	if (type->kind == 2) 
		dell(type->u.array.elem);
	else 
		del(type->u.structure);
}

int main(int argc, char **argv) {
	init();
	FILE *f = fopen(argv[1], "r");
	if (!f) {
		perror(argv[1]); return 1;
	}
	root = NULL; 
	yyrestart(f); yyparse();
	travel(root);
	return 0;
}

yyerror(char *msg) {
	printf("syntax error!\n");
}
